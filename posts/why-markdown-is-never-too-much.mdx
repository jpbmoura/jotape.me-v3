---
title: "Criando um blog com MDX, Next.js e Tailwind: Porque markdown nunca √© demais"
abstract: "Enquanto escrevia um post sobre Curvas de B√©zier Din√¢micas, percebi que estava gastando mais tempo escrevendo o c√≥digo do componente do post do que no pr√≥prio texto. Foi a√≠ que me bateu a d√∫vida: ser√° que n√£o existe uma forma melhor de integrar c√≥digo e conte√∫do?"
publishedOn: "2025-03-04T12:00:00-0400"
---

Enquanto escrevia um post sobre Curvas de B√©zier Din√¢micas (**em breve nesse mesmo bat-canal**), percebi que estava gastando mais tempo escrevendo o c√≥digo do componente do post do que no pr√≥prio texto. Foi a√≠ que me bateu a d√∫vida: **_"ser√° que n√£o existe uma forma melhor de integrar c√≥digo e conte√∫do?"_**

Depois de explorar algumas op√ß√µes, decidi mudar tudo e construir meu blog usando **MDX**. No entanto, integrar essa abordagem √† minha stack n√£o foi t√£o simples quanto eu esperava. Passei por alguns desafios, quebrei a cabe√ßa ajustando configura√ß√µes, mas no fim, cheguei √† vers√£o do blog que voc√™ est√° lendo agora.

Neste artigo, vou compartilhar todo o processo de cria√ß√£o, desde a configura√ß√£o inicial at√© os ajustes finais, para que voc√™ possa criar seu pr√≥prio blog com **Next.js**, **MDX** e **Tailwind CSS** sem as mesmas dores de cabe√ßa. Mas antes: Por que MDX?

## O que √© MDX e por que us√°-lo?

Se voc√™ j√° escreveu em **Markdown**, sabe o quanto ele facilita a vida. Com uma sintaxe simples e direta, d√° para formatar texto sem precisar lidar com HTML ou editores visuais cheios de firulas. Mas e se desse para ir al√©m e misturar Markdown com componentes React? Pois bem, jovem, √© exatamente isso que o MDX faz.

O **MDX (Markdown + JSX)** permite escrever posts em Markdown e, ao mesmo tempo, utilizar componentes React dentro do conte√∫do. Isso significa que, al√©m de texto, listas e imagens, voc√™ pode inserir bot√µes, gr√°ficos dan√ßantes, alertas pulsantes e qualquer outro componente React. Era exatamente essa flexibilidade que eu precisava para ilustrar melhor meus conceitos e tornar o blog mais envolvente.

## Configurando o Ambiente e o suporte a MDX no Next.js

Vamos come√ßar criando nosso projeto com Next.js. Para isso, utilizaremos o <TomatoMono>@next/mdx</TomatoMono>, uma lib oficial do Next.js que facilita o suporte ao MDX.

#### Criando o projeto

No terminal, execute o comando abaixo:

```shell
npx create-next-app@latest
```

```shell
What is your project named? mdx-blog
Would you like to use TypeScript? Yes
Would you like to use ESLint? Yes
Would you like to use Tailwind CSS? Yes
Would you like your code inside a `src/` directory? Yes
Would you like to use App Router? (recommended) Yes
Would you like to use Turbopack for `next dev`?  No
Would you like to customize the import alias (`@/*` by default)? No
```

E agora algumas depend√™ncias para o MDX:

```bash
npm install @next/mdx @mdx-js/loader @mdx-js/react @types/mdx gray-matter remark-frontmatter remark-mdx-frontmatter
```

Por que tantas depend√™ncias? (maldito JavaScript üòí)

- **@next/mdx, @mdx-js/loader, @mdx-js/react, @types/mdx** ‚Üí Permitem que o Next.js suporte arquivos MDX, possibilitando o uso de Markdown misturado com JSX.
- **gray-matter** ‚Üí Biblioteca que extrai metadados de arquivos Markdown/MDX usando frontmatter, um bloco de YAML (ou JSON/TOML) no topo do arquivo.
- **remark-frontmatter, remark-mdx-frontmatter** ‚Üí Faz com que o parser do MDX reconhe√ßa blocos de frontmatter no formato YAML, JSON ou TOML e converte o frontmatter extra√≠do em um objeto acess√≠vel dentro do MDX.

<ArticleNote type="info">
O que √© _frontmatter_ e como o _gray-matter_ funciona? ü§î

O Frontmatter √© um bloco de metadados que fica no in√≠cio de arquivos Markdown ou MDX, delimitado por tr√™s tra√ßos (<TomatoMono>---</TomatoMono>). Ele √© usado para armazenar informa√ß√µes estruturadas sobre o documento, como t√≠tulo, data, autor e tags.

A biblioteca gray-matter separa esses metadados e os transforma em um objeto JavaScript. Exemplo de um arquivo <TomatoMono>.mdx</TomatoMono>:

```posts/exemple.mdx
---
title: "Meu Primeiro Post"
abstract: "resumo do conte√∫do para mostrar na listagem de posts"
publishedOn: "2024-04-01T12:00:00-0400"
---

Esse √© o conte√∫do do post em **Markdown**.
```

Se processarmos esse arquivo com <TomatoMono>gray-matter</TomatoMono>, obteremos:

```json
{
  "frontmatter": {
    "title": "Meu Primeiro Post",
    "abstract": "resumo do conte√∫do para mostrar na listagem de posts",
    "publishedOn": "2024-04-01T12:00:00-0400"
  },
  "content": "Esse √© o conte√∫do do post em **Markdown**."
}
```

Coisa linda! ü§©

</ArticleNote>

Agora que temos o projeto configurado, vamos integrar o **MDX** ao **Next.js**:

```next-config.ts
import createMDX from "@next/mdx";
import remarkFrontmatter from "remark-frontmatter";
import remarkMDXFrontmatter from "remark-mdx-frontmatter";

/** @type {import('next').NextConfig} */
const nextConfig = {
  pageExtensions: ["js", "jsx", "md", "mdx", "ts", "tsx"],
};

const withMDX = createMDX({
  options: {
    remarkPlugins: [remarkFrontmatter, remarkMDXFrontmatter],
  },
});

export default withMDX(nextConfig);
```

Mas o que exatamente esse c√≥digo faz?

- Adiciona suporte a arquivos **MDX** no **Next.js** usando <TomatoMono>@next/mdx</TomatoMono>.
- Habilita a leitura de **frontmatter** (metadados no topo dos arquivos MDX) com os plugins <TomatoMono>remark-frontmatter</TomatoMono> e <TomatoMono>remark-mdx-frontmatter</TomatoMono>.
- Define extens√µes de p√°gina (<TomatoMono>.mdx</TomatoMono>, <TomatoMono>.md</TomatoMono>, <TomatoMono>.js</TomatoMono>, <TomatoMono>.jsx</TomatoMono>, <TomatoMono>.ts</TomatoMono>, <TomatoMono>.tsx</TomatoMono>), permitindo que arquivos nesses formatos sejam tratados como p√°ginas no **Next.js**.

## Criando p√°ginas de postagens din√¢micas

Agora com o projeto configurado, podemos come√ßar a estruturar nosso blog. Vamos utilizar a seguinte arquitetura:

```md
‚î£ üìÇ public/
‚î£ üìÇ posts/ #posts e p√°ginas escritas em MDX
‚îÉ ‚î£ exemple.mdx
‚î£ üìÇ src/
‚îÉ ‚î£ üìÇ app/
‚îÉ ‚îÉ ‚î£ üìÇ blog/ #p√°gina principal do blog (lista de posts)
‚îÉ ‚îÉ ‚îÉ ‚î£ üìÇ [slug]/ #rota din√¢mina para exibir posts individuais
‚îÉ ‚îÉ ‚îÉ ‚îÉ ‚î£ page.tsx
‚îÉ ‚îÉ ‚îÉ ‚î£ page.tsx
‚îÉ ‚îÉ ‚î£ globals.css
‚îÉ ‚îÉ ‚î£ layout.tsx
‚îÉ ‚îÉ ‚î£ page.tsx
‚îÉ ‚î£ üìÇ components/
‚îÉ ‚î£ üìÇ widgets/ #componentes que ser√£o utilizados dentro do MDX
‚îÉ ‚î£ üìÇ utils/ #fun√ß√µes auxiliares, como processamento de frontmatter
‚îÉ ‚î£ üìÇ lib/ #configura√ß√µes de MDX, carregamento de arquivos, etc.
‚îÉ ‚î£ mdx-components.tsx #falaremos sobre esse carinha depois
‚î£ .gitignore #arquivos e pastas ignoradas no git
‚î£ package.json #depend√™ncias e scripts do projeto
‚î£ next.config.js #configura√ß√£o do Next.js, incluindo suporte a MDX
‚î£ README.md #documenta√ß√£o do projeto
```

#### [slug]?

No **Next.js**, <TomatoMono>[slug]</TomatoMono> √© uma [rota din√¢mica](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes) que permite gerar p√°ginas automaticamente com base em um identificador √∫nico ‚Äî neste caso, o nome do arquivo **MDX**. Em vez de criarmos uma p√°gina manualmente para cada post, o **Next.js** carrega e renderiza o conte√∫do de forma din√¢mica conforme a URL acessada.

Dentro do arquivo <TomatoMono>page.tsx</TomatoMono> da rota <TomatoMono>[slug]</TomatoMono>, vamos criar um componente que captura o nome do arquivo MDX a partir da URL (por exemplo, <TomatoMono>/blog/post-exemplo</TomatoMono>), busca o arquivo correspondente (<TomatoMono>post-exemplo.mdx</TomatoMono>) e o exibe na tela.

O c√≥digo ficar√° mais ou menos assim:

```src/app/blog/[slug]/page.tsx
export default async function PostPage({
  params,
}: {
  params: { slug: string };
}) {
  try {
    // Importa dinamicamente o post com base no slug da URL
    const { default: Post } = await import(
      `../../../../posts/${params.slug}.mdx`
    );

    return (
      <article>
        <div>
          <span>{/* Title */}</span>
          <span>{/* PublishedOn */}</span>
        </div>

        <Post />
      </article>
    );
  } catch (error) {
    // Se o arquivo n√£o for encontrado, retorna uma p√°gina 404
    notFound();
  }
}
```

Com essa abordagem, sempre que adicionarmos um novo post em <TomatoMono>posts/</TomatoMono>, ele ser√° automaticamente acess√≠vel via <TomatoMono>/blog/nome-do-post</TomatoMono>, sem precisar configurar nada manualmente!

Mas ainda temos um problema: **_como acessar os preciosos metadados dos nossos posts?_** Afinal, precisamos exibir informa√ß√µes essenciais, como o t√≠tulo, a data de publica√ß√£o e qualquer outro dado relevante para melhorar a experi√™ncia do leitor.

#### Criando o posts-helpers.ts

Para organizar melhor nosso c√≥digo, vamos criar um arquivo <TomatoMono>posts-helpers.ts</TomatoMono> dentro da pasta <TomatoMono>utils/</TomatoMono>. Esse arquivo conter√° fun√ß√µes auxiliares para manipular os posts do blog, como listar posts e carregar o conte√∫do de um post espec√≠fico.

```src/utils/posts-helpers.ts
import fs from "fs/promises";
import path from "path";
import matter from "gray-matter";

type BlogPost = {
  slug: string;
  title: string;
  abstract: string;
  publishedOn: string; // Pode ser `Date` se preferir trabalhar com objetos de data
};

/**
 * Retorna a lista de posts do blog ordenada pela data de publica√ß√£o (mais recentes primeiro).
 */
export async function getBlogPostList(): Promise<BlogPost[]> {
  const fileNames = await readDirectory("posts"); // Obt√©m a lista de arquivos na pasta `posts/`
  const blogPosts: BlogPost[] = [];

  for (const fileName of fileNames) {
    const rawContent = await readFile(`posts/${fileName}`);
    const { data: frontmatter } = matter(rawContent); // Extrai os metadados (frontmatter)

    blogPosts.push({
      ...(frontmatter as Omit<BlogPost, "slug">),
      slug: fileName.replace(".mdx", ""), // O slug √© o nome do arquivo sem a extens√£o
    });
  }

  // Ordena os posts da data mais recente para a mais antiga
  return blogPosts.sort((a, b) => (a.publishedOn < b.publishedOn ? 1 : -1));
}

/**
 * Carrega o conte√∫do de um post espec√≠fico com base no `slug`.
 */
export async function loadBlogPost(slug: string) {
  const rawContent = await readFile(`posts/${slug}.mdx`);
  const { data: frontmatter, content } = matter(rawContent);

  return { frontmatter, content };
}

/**
 * L√™ o conte√∫do de um arquivo dentro da estrutura do projeto.
 */
async function readFile(localPath: string) {
  return fs.readFile(path.join(process.cwd(), localPath), "utf8");
}

/**
 * L√™ os nomes dos arquivos dentro de um diret√≥rio.
 */
async function readDirectory(localPath: string) {
  return fs.readdir(path.join(process.cwd(), localPath));
}
```

**Maravilha!** ü•≥ Com nossas fun√ß√µes auxiliares criadas, podemos voltar √† nossa p√°gina din√¢mica <TomatoMono>[slug]</TomatoMono> e ajust√°-la para carregar corretamente os posts do blog.

```src/app/blog/[slug]/page.tsx
export default async function PostPage({
  params,
}: {
  params: { slug: string };
}) {
  try {
    const { default: Post } = await import(`../../../../posts/${params.slug}.mdx`);
    const { frontmatter } = await loadBlogPost(params.slug);

    return (
      <article>
	    <div>
	      <span>{frontmatter.title}</span>
	      <span>{frontmatter.publishedOn}</span>
	    </div>
        <Post />
      </article>
    );
  } catch (error) {
    notFound();
  }
}
```

Agora que nossa p√°gina din√¢mica <TomatoMono>[slug]</TomatoMono> est√° pronta, vamos configurar a listagem de posts para exibi-los na p√°gina principal do blog!

#### Listar todos os posts na rota /blog

Todo blog que se preze precisa de uma **p√°gina dedicada** para listar seus posts, permitindo que os leitores naveguem e escolham o que desejam ler. Vamos criar essa listagem dentro da rota <TomatoMono>/blog</TomatoMono> e exibir os posts dinamicamente.

```src/app/blog/page.tsx
import { getBlogPostList } from "@/utils/functions/posts-helpers";

export default async function BlogPage() {
  const blogPosts = await getBlogPostList();

  return (
    <div>
      <h1>Meu MDX-Blog</h1>

      <div>
        {blogPosts.map(({ slug, title, abstract, publishedOn }) => (
          <Link href={`/blog/${slug}`}>
		    <div>
			  <h2>{title}</h2>
			  <time dateTime={publishedOn}>
			    {new Date(publishedOn).toLocaleDateString()}
			  </time>
			</div>

			<p>{abstract}</p>
			<span>Continue lendo ‚Üí</span>
		  </Link>
        ))}
      </div>
    </div>
  );
}
```

## E o Tailwind?

Para que o nosso querido **Tailwind** funcione corretamente dentro dos arquivos **MDX**, precisamos realizar algumas configura√ß√µes essenciais.

1. O **Tailwind** possui um plugin oficial chamado <TomatoMono>@tailwindcss/typography</TomatoMono>, que melhora a renderiza√ß√£o de textos. Vamos instal√°-lo:

```bash
npm install @tailwindcss/typography
```

2.  Agora, precisamos adicionar o plugin ao nosso <TomatoMono>global.css</TomatoMono>:

```src/app/globals.css
@import "tailwindcss";

@plugin "@tailwindcss/typography";
```

3. Para garantir que nossos posts fiquem bem estilizados, vamos criar um componente de layout chamado <TomatoMono>MDXLayout</TomatoMono> dentro da pasta **components**

```src/components/mdx-layout.tsx
interface MDXLayoutPropsProps {
  children: React.ReactNode;
}

export default function MDXLayout({ children }: MDXLayoutPropsProps) {
  return (
    <section className="prose prose-a:text-white prose-headings:text-start prose-strong:text-white text-text-dark prose-headings:mt-8 prose-headings:font-semibold prose-headings:text-text-dark prose-h1:text-5xl prose-h2:text-4xl prose-h3:text-3xl prose-h4:text-2xl prose-h5:text-xl prose-h6:text-lg dark:prose-headings:text-white">
      {children}
    </section>
  );
}
```

<ArticleNote type="info">
  As classes que estou utilizando s√£o as que utilizo nesse blog que voc√™ est√°
  lendo. Mude, brinque e teste com outras varia√ß√µes para que seu blog fique com
  sua cara ü§ì
</ArticleNote>

4. Agora, vamos envolver os posts com nosso <TomatoMono>MDXLayout</TomatoMono>, garantindo que o **Tailwind** estilize corretamente o conte√∫do.

```src/app/blog/[slug]/page.tsx
import MDXLayout from "@/components/mdx-layout";

export default async function PostPage({
  params,
}: {
  params: { slug: string };
}) {
  try {
    const { default: Post } = await import(`../../../../posts/${params.slug}.mdx`);
    const { frontmatter } = await loadBlogPost(params.slug);

    return (
      <article>
	      <div>
	        <span>{frontmatter.title}</span>
	        <span>{frontmatter.publishedOn}</span>
	      </div>
          <MDXLayout>
	        <Post />
	      </MDXLayout>
      </article>
    );
  } catch (error) {
    notFound();
  }
}
```

#### Usando componentes React dentro do MDX

Uma das grandes vantagens do **MDX** √© a possibilidade de incluir componentes React dentro dos posts. Para que isso funcione corretamente no **Next.js**, precisamos configurar um arquivo especial chamado <TomatoMono>mdx-components.tsx</TomatoMono>, que define quais componentes estar√£o dispon√≠veis dentro dos arquivos **MDX**.

```src/mdx-components.tsx
import type { MDXComponents } from "mdx/types";

import ChromaticCircle from "@/widgets/chromatic-circle";

export function useMDXComponents(components: MDXComponents): MDXComponents {
  return {
    ...components,
    ChromaticCircle // Disponibiliza o componente dentro dos arquivos MDX
  };
}
```

Agora que registramos o componente, podemos utiliz√°-lo dentro de um post **MDX**:

```posts/exemple.mdx
## C√≠rculo Crom√°tico

Uma ferramenta fundamental para qualquer ...

<ChromaticCircle type="selector" />
```

Mas aten√ß√£o: o **Next.js** consegue localizar os componentes apenas se eles estiverem dentro da pasta <TomatoMono>src/</TomatoMono>. Certifique-se de que a estrutura esteja organizada corretamente:

```mdx
üìÇ src/
‚î£ üìÇ components/
‚î£ üìÇ widgets/ <-- Componentes para MDX
‚îÉ ‚îó üìú chromatic-circle.tsx
‚îó üìú mdx-components.tsx
```

<ArticleNote type="info">
  Eu gosto de separar os componentes que vou utilizar nos arquivos MDX na pasta
  <TomatoMono>widget/</TomatoMono> ao inves da components, mas isso √© preferencia
  minha. Voc√™ pode organizar como achar melhor.
</ArticleNote>

## That's All, Folks!

Agora basta come√ßar a criar seus mdx dentro da pasta post e ser feliz com seu novo blog com **MDX + Next.js + Tailwind**. Lembre-se que esse √© somente um esqueleto para seu blog, **o resto √© com voc√™!**

Muito obrigado pela sua preciosa aten√ß√£o. At√© a pr√≥xima!
